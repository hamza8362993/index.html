<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>IsoCity — Prototype Pixel Isométrique</title>
<style>
  :root{--bg:#0b1220;--panel:#06131a;--accent:#00d3ff;--muted:#9fbccf}
  html,body{height:100%;margin:0;background:var(--bg);font-family:Inter,Arial;color:#e6fbff}
  #wrap{display:flex;gap:10px;height:100vh}
  #left{flex:1;position:relative;background:#05141a}
  #ui{width:300px;background:linear-gradient(#04121a,#031418);padding:12px;box-sizing:border-box;border-left:1px solid rgba(255,255,255,0.03)}
  canvas{display:block;background:linear-gradient(#0a1820,#042029)}
  h1{margin:0;color:var(--accent);font-size:18px}
  button{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:#cfe}
  .row{display:flex;gap:8px;margin-top:8px}
  .small{font-size:13px;color:#9fbccf}
  input[type=range]{width:100%}
  .counter{margin-top:10px;padding:8px;background:rgba(0,0,0,0.12);border-radius:8px}
  footer{position:absolute;left:10px;bottom:8px;color:#7fb}
  .toolBtn.active{border-color:var(--accent);box-shadow:0 6px 18px rgba(0,211,255,0.04)}
</style>
</head>
<body>
<div id="wrap">
  <div id="left">
    <canvas id="c"></canvas>
    <footer>IsoCity — prototype • créé par hamza</footer>
  </div>
  <div id="ui">
    <h1>IsoCity</h1>
    <div class="small">Outils</div>
    <div class="row" style="margin-top:8px">
      <button id="b-road" class="toolBtn active">Route</button>
      <button id="b-house" class="toolBtn">Maison</button>
      <button id="b-tree" class="toolBtn">Arbre</button>
      <button id="b-bill" class="toolBtn">Panneau</button>
      <button id="b-erase" class="toolBtn">Gomme</button>
    </div>

    <div class="small" style="margin-top:12px">Simulation</div>
    <div class="row" style="margin-top:8px">
      <button id="start">Démarrer</button>
      <button id="pause">Pause</button>
      <button id="reset">Reset</button>
    </div>

    <div class="counter">
      <div>Voitures : <span id="cars">0</span></div>
      <div>Maisons : <span id="houses">0</span></div>
      <div class="small" style="margin-top:6px">Spawn cars / s</div>
      <input id="spawn" type="range" min="0" max="2" step="0.05" value="0.6">
    </div>

    <div style="margin-top:10px">
      <div class="small">Zoom</div>
      <input id="zoom" type="range" min="0.6" max="1.8" step="0.05" value="1">
    </div>

    <div style="margin-top:10px">
      <button id="save">Sauvegarder</button>
      <button id="load">Charger</button>
    </div>

    <div style="margin-top:12px" class="small">Astuce : clique & dessine routes, place maisons à côté des routes, lance la simulation.</div>
  </div>
</div>

<script>
/* ===== IsoCity prototype (isometric, pixel-style) =====
  - grid tilemap (isometric)
  - tools: draw road / house / tree / billboard / erase
  - cars use A* on road graph
  - pixel-ish drawing using canvas (no external images)
*/

// ---------- Config ----------
const TILE_W = 64, TILE_H = 32;    // base tile size (pixels)
const MAP_W = 80, MAP_H = 80;      // map tiles
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let DPR = window.devicePixelRatio || 1;

function resizeCanvas(){
  canvas.width = Math.floor(window.innerWidth*0.86 * DPR);
  canvas.height = Math.floor(window.innerHeight * DPR);
  canvas.style.width = Math.floor(window.innerWidth*0.86) + 'px';
  canvas.style.height = window.innerHeight + 'px';
}
window.addEventListener('resize', ()=>{ DPR = window.devicePixelRatio || 1; resizeCanvas(); });
resizeCanvas();

// camera/pan/zoom
let camX = canvas.width/2 / DPR, camY = 140, zoom = 1;
const zoomSlider = document.getElementById('zoom');
zoomSlider.oninput = ()=> { zoom = parseFloat(zoomSlider.value); render(); };

let isPanning=false, lastPan=null;
canvas.addEventListener('mousedown', e=>{
  if(e.button===1 || e.button===2){ isPanning=true; lastPan={x:e.clientX,y:e.clientY}; return; }
  handlePointer(e);
});
canvas.addEventListener('mousemove', e=>{ if(isPanning && lastPan){ camX += e.clientX - lastPan.x; camY += e.clientY - lastPan.y; lastPan={x:e.clientX,y:e.clientY}; render(); } else if(mouseDown){ handlePointer(e); }});
window.addEventListener('mouseup', ()=>{ isPanning=false; lastPan=null; mouseDown=false; });
canvas.addEventListener('wheel', e=>{ e.preventDefault(); zoom *= (e.deltaY>0?0.95:1.05); zoom=Math.max(0.6, Math.min(1.8, zoom)); zoomSlider.value=zoom; render(); }, {passive:false});

// map data: 0 empty, 1 road, 2 house, 3 tree, 4 billboard
const map = new Uint8Array(MAP_W * MAP_H);
const houses = []; // {i,j}
const billboards = [];

// helpers
function idx(i,j){ return i + j*MAP_W; }
function inside(i,j){ return i>=0 && j>=0 && i<MAP_W && j<MAP_H; }

// isometric projection grid->screen
function isoToScreen(i,j){
  const x = (i - j) * (TILE_W/2) * zoom + camX;
  const y = (i + j) * (TILE_H/2) * zoom + camY;
  return {x,y};
}
function screenToIso(sx,sy){
  const x = (sx - camX)/zoom;
  const y = (sy - camY)/zoom;
  const i = Math.floor((y / (TILE_H/2) + x / (TILE_W/2)) / 2);
  const j = Math.floor((y / (TILE_H/2) - x / (TILE_W/2)) / 2);
  return {i,j};
}

// draw pixel-ish ground tile
function drawGround(i,j){
  const p = isoToScreen(i,j);
  // diamond filled with subtle texture
  const grad = ctx.createLinearGradient(p.x, p.y - TILE_H*0.45*zoom, p.x, p.y + TILE_H*0.45*zoom);
  grad.addColorStop(0, "#274b3a");
  grad.addColorStop(1, "#1c3a2b");
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.moveTo(p.x, p.y - (TILE_H/2)*zoom);
  ctx.lineTo(p.x + (TILE_W/2)*zoom, p.y);
  ctx.lineTo(p.x, p.y + (TILE_H/2)*zoom);
  ctx.lineTo(p.x - (TILE_W/2)*zoom, p.y);
  ctx.closePath();
  ctx.fill();
  // pixel border
  ctx.strokeStyle = "rgba(0,0,0,0.15)";
  ctx.stroke();
}

// draw road tile (isometric rectangle)
function drawRoad(i,j){
  const p = isoToScreen(i,j);
  ctx.fillStyle = "#3a3a3a";
  ctx.beginPath();
  ctx.moveTo(p.x - (TILE_W/4)*zoom, p.y - (TILE_H/8)*zoom);
  ctx.lineTo(p.x + (TILE_W/4)*zoom, p.y - (TILE_H/8)*zoom);
  ctx.lineTo(p.x + (TILE_W/4)*zoom, p.y + (TILE_H/8)*zoom);
  ctx.lineTo(p.x - (TILE_W/4)*zoom, p.y + (TILE_H/8)*zoom);
  ctx.closePath();
  ctx.fill();
  // center line hint occasional
  ctx.strokeStyle = "rgba(255,255,255,0.06)";
  ctx.stroke();
}

// draw house sprite (simple isometric house pixel style)
function drawHouse(i,j){
  const p = isoToScreen(i,j);
  const baseW = 34*zoom, baseH = 20*zoom;
  // base
  ctx.fillStyle = "#d9b89b";
  ctx.beginPath();
  ctx.moveTo(p.x - baseW/2, p.y);
  ctx.lineTo(p.x, p.y - baseH);
  ctx.lineTo(p.x + baseW/2, p.y);
  ctx.lineTo(p.x, p.y + baseH/2);
  ctx.closePath();
  ctx.fill();
  // roof
  ctx.fillStyle = "#7a2d2d";
  ctx.beginPath();
  ctx.moveTo(p.x - baseW/2, p.y);
  ctx.lineTo(p.x, p.y - (baseH + 12*zoom));
  ctx.lineTo(p.x + baseW/2, p.y);
  ctx.closePath();
  ctx.fill();
  // small door
  ctx.fillStyle = "#4a2f24";
  ctx.fillRect(p.x-6*zoom, p.y - 6*zoom, 8*zoom, 8*zoom);
}

// draw tree
function drawTree(i,j){
  const p = isoToScreen(i,j);
  ctx.fillStyle = "#1d6f39";
  ctx.beginPath();
  ctx.arc(p.x, p.y - 6*zoom, 10*zoom, 0, Math.PI*2);
  ctx.fill();
  ctx.fillStyle = "#3b1f09";
  ctx.fillRect(p.x-2*zoom, p.y-6*zoom, 4*zoom, 8*zoom);
}

// billboard
function drawBill(i,j){
  const p = isoToScreen(i,j);
  ctx.fillStyle = "#ffffff";
  ctx.fillRect(p.x + 12*zoom, p.y - 28*zoom, 36*zoom, 18*zoom);
  ctx.fillStyle = "#c33";
  ctx.fillText("SALE", p.x + 18*zoom, p.y - 16*zoom);
  // pole
  ctx.fillStyle = "#999";
  ctx.fillRect(p.x+20*zoom, p.y - 10*zoom, 4*zoom, 24*zoom);
}

// render map
function render(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save();
  ctx.scale(DPR,DPR);
  // draw ground tiles in painter order
  for(let j=0;j<MAP_H;j++){
    for(let i=0;i<MAP_W;i++){
      const p = isoToScreen(i,j);
      // quick cull
      if(p.x < -200 || p.x > canvas.width/DPR + 200 || p.y < -200 || p.y > canvas.height/DPR + 200) continue;
      drawGround(i,j);
      const t = map[idx(i,j)];
      if(t===1) drawRoad(i,j);
      else if(t===2) drawHouse(i,j);
      else if(t===3) drawTree(i,j);
      else if(t===4) drawBill(i,j);
    }
  }
  // draw cars (after map)
  for(const car of cars) drawCar(car);
  // HUD small counts
  document.getElementById('cars').textContent = cars.length;
  document.getElementById('houses').textContent = houses.length;
  ctx.restore();
}

// ---------- tools & input ----------
let currentTool='road';
const setTool = t=> {
  currentTool=t;
  document.querySelectorAll('.toolBtn').forEach(b=>b.classList.toggle('active', b.id === 'b-'+t));
};
document.getElementById('b-road').onclick = ()=> setTool('road');
document.getElementById('b-house').onclick = ()=> setTool('house');
document.getElementById('b-tree').onclick = ()=> setTool('tree');
document.getElementById('b-bill').onclick = ()=> setTool('bill');
document.getElementById('b-erase').onclick = ()=> setTool('erase');

let mouseDown=false;
canvas.addEventListener('mousedown', e=>{
  if(e.button===1||e.button===2){ isPanning=true; lastPan={x:e.clientX,y:e.clientY}; return; }
  mouseDown=true;
  handlePointer(e);
});
canvas.addEventListener('mouseup', ()=>mouseDown=false);
canvas.addEventListener('mousemove', e=>{ if(mouseDown) handlePointer(e); if(isPanning && lastPan){ camX += e.clientX - lastPan.x; camY += e.clientY - lastPan.y; lastPan={x:e.clientX,y:e.clientY}; render(); } });

function handlePointer(e){
  const rc = canvas.getBoundingClientRect();
  const sx = (e.clientX - rc.left);
  const sy = (e.clientY - rc.top);
  const {i,j} = screenToIso(sx,sy);
  if(!inside(i,j)) return;
  if(currentTool==='road'){ map[idx(i,j)] = 1; }
  else if(currentTool==='house'){ if(hasAdjacentRoad(i,j)){ map[idx(i,j)] = 2; houses.push({i,j}); } }
  else if(currentTool==='tree'){ map[idx(i,j)] = 3; }
  else if(currentTool==='bill'){ map[idx(i,j)] = 4; billboards.push({i,j}); }
  else if(currentTool==='erase'){ if(map[idx(i,j)]===2) { // remove house
      for(let k=houses.length-1;k>=0;k--) if(houses[k].i===i && houses[k].j===j) houses.splice(k,1);
    } map[idx(i,j)] = 0; }
  render();
}

function hasAdjacentRoad(i,j){
  const d=[[1,0],[-1,0],[0,1],[0,-1]];
  for(const dd of d) if(inside(i+dd[0],j+dd[1]) && map[idx(i+dd[0],j+dd[1])]==1) return true;
  return false;
}

// ---------- A* pathfinding on roads ----------
function buildRoadGraph(){
  const nodes = {};
  for(let j=0;j<MAP_H;j++) for(let i=0;i<MAP_W;i++){
    if(map[idx(i,j)]===1){
      const key = i+','+j;
      nodes[key] = [];
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      for(const d of dirs) if(inside(i+d[0],j+d[1]) && map[idx(i+d[0],j+d[1])]==1) nodes[key].push((i+d[0])+','+(j+d[1]));
    }
  }
  return nodes;
}

function findNearestRoad(i,j){
  if(map[idx(i,j)]===1) return {i,j};
  // BFS small radius
  const maxR=6;
  for(let r=1;r<=maxR;r++){
    for(let dx=-r;dx<=r;dx++){
      for(let dy=-r;dy<=r;dy++){
        if(Math.abs(dx)!==r && Math.abs(dy)!==r) continue;
        const ni=i+dx,nj=j+dy;
        if(!inside(ni,nj)) continue;
        if(map[idx(ni,nj)]===1) return {i:ni,j:nj};
      }
    }
  }
  return null;
}

function astar(start,goal,graph){
  const startKey = start.i+','+start.j;
  const goalKey = goal.i+','+goal.j;
  if(!graph[startKey] || !graph[goalKey]) return null;
  const open = new Map();
  const closed = new Set();
  function h(k){ const [x,y]=k.split(',').map(Number); const [gx,gy]=goalKey.split(',').map(Number); return Math.abs(x-gx)+Math.abs(y-gy); }
  open.set(startKey,{k:startKey,g:0,f:h(startKey),parent:null});
  const maxIter=5000; let iter=0;
  while(open.size && iter++<maxIter){
    // get lowest f
    let bestKey, bestNode;
    for(const [k,node] of open) if(!bestNode || node.f < bestNode.f){ bestNode=node; bestKey=k; }
    open.delete(bestKey);
    if(bestKey===goalKey){
      // reconstruct
      const path=[];
      let n=bestNode;
      while(n){ const [xi,yi]=n.k.split(',').map(Number); path.push({i:xi,j:yi}); n=n.parent; }
      path.reverse(); return path;
    }
    closed.add(bestKey);
    for(const nb of graph[bestKey]){
      if(closed.has(nb)) continue;
      const g = bestNode.g + 1;
      const existing = open.get(nb);
      const f = g + h(nb);
      if(!existing || g < existing.g) open.set(nb,{k:nb,g,f,parent:bestNode});
    }
  }
  return null;
}

// ---------- cars simulation ----------
const cars = [];
let carId = 1;
function spawnCar(){
  if(houses.length < 2) return;
  // pick two random houses
  const a = houses[Math.floor(Math.random()*houses.length)];
  let b = houses[Math.floor(Math.random()*houses.length)];
  if(!b || (b.i===a.i && b.j===a.j)) return;
  const start = findNearestRoad(a.i,a.j);
  const goal = findNearestRoad(b.i,b.j);
  if(!start || !goal) return;
  const graph = buildRoadGraph();
  const path = astar(start,goal,graph);
  if(!path || path.length<2) return;
  const car = {id:carId++, path, idx:0, t:0, speed:0.003 + Math.random()*0.006, color:randomColor()};
  cars.push(car);
}

function randomColor(){
  const cols = ["#ffcc00","#ff6666","#66ff66","#66ccff","#ff66cc","#ffaa66"];
  return cols[Math.floor(Math.random()*cols.length)];
}

function updateCars(dt){
  for(let k=cars.length-1;k>=0;k--){
    const c = cars[k];
    const seg = c.path;
    c.t += c.speed * dt;
    if(c.t >= 1){ c.idx++; c.t = 0; }
    if(c.idx >= seg.length-1){ cars.splice(k,1); continue; }
  }
}

function drawCar(car){
  // compute interp pos between path[idx] and path[idx+1]
  const a = car.path[car.idx], b = car.path[car.idx+1] || a;
  const px = a.i + (b.i - a.i) * car.t;
  const py = a.j + (b.j - a.j) * car.t;
  const p = isoToScreen(px, py);
  // small pixel car
  ctx.fillStyle = car.color;
  ctx.fillRect(p.x - 6*zoom, p.y - 8*zoom, 12*zoom, 6*zoom);
  // tiny windows
  ctx.fillStyle = "#e6ffff";
  ctx.fillRect(p.x - 2*zoom, p.y - 7*zoom, 4*zoom, 3*zoom);
}

// main loop
let last = performance.now();
let running = false;
let spawnRate = parseFloat(document.getElementById('spawn').value);
document.getElementById('spawn').oninput = e=> spawnRate = parseFloat(e.target.value);

function loop(){
  const now = performance.now();
  const dt = Math.min(60, now - last);
  last = now;
  if(running){
    // spawn logic
    if(Math.random() < spawnRate * dt * 0.001) spawnCar();
    updateCars(dt);
  }
  renderCars();
  requestAnimationFrame(loop);
}
function renderCars(){
  // draw map + cars
  render();
  // draw cars after map
  for(const c of cars) drawCar(c);
}
loop();

// UI controls
document.getElementById('start').onclick = ()=> running = true;
document.getElementById('pause').onclick = ()=> running = false;
document.getElementById('reset').onclick = ()=> { for(let i=0;i<map.length;i++) map[i]=0; houses.length=0; billboards.length=0; cars.length=0; render(); };

// save/load
document.getElementById('save').onclick = ()=>{
  const data = {map: Array.from(map), houses, billboards, camX, camY, zoom};
  localStorage.setItem('isocity_save', JSON.stringify(data));
  alert('Sauvegardé');
};
document.getElementById('load').onclick = ()=>{
  const raw = localStorage.getItem('isocity_save'); if(!raw) return alert('Aucune sauvegarde');
  const d = JSON.parse(raw); for(let i=0;i<d.map.length;i++) map[i]=d.map[i]; houses.length=0; if(d.houses) for(const h of d.houses) houses.push(h); render();
};

// simple demo seed
(function seed(){
  // horizontal highway
  for(let x=10;x<70;x++) map[idx(x,30)] = 1;
  for(let y=20;y<40;y++) map[idx(40,y)] = 1;
  // small houses
  map[idx(39,29)]=2; houses.push({i:39,j:29});
  map[idx(41,29)]=2; houses.push({i:41,j:29});
  map[idx(38,32)]=2; houses.push({i:38,j:32});
  map[idx(42,32)]=2; houses.push({i:42,j:32});
  render();
})();

// pointer handling small helpers
let isPanning=false, mouseDown=false, lastPan=null;
canvas.addEventListener('mousedown', (e)=>{ if(e.button===1||e.button===2){ isPanning=true; lastPan={x:e.clientX,y:e.clientY}; return;} mouseDown=true; handlePointer(e); });
canvas.addEventListener('mouseup', ()=>{ mouseDown=false; isPanning=false; lastPan=null; });
canvas.addEventListener('mousemove', (e)=>{ if(isPanning && lastPan){ camX += e.clientX - lastPan.x; camY += e.clientY - lastPan.y; lastPan={x:e.clientX,y:e.clientY}; render(); } if(mouseDown) handlePointer(e); });

// initial render
render();

</script>
</body>
</html>
