<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>MiniCity — Prototype</title>
<style>
  :root{
    --bg:#0b1020; --panel:#071228; --accent:#00d1ff; --muted:#9fbccf;
  }
  html,body{height:100%;margin:0;background:var(--bg);font-family:Inter,Arial;color:#dff9ff}
  #app{display:flex;height:100vh;gap:10px}
  #left{width:86%;position:relative}
  #ui{width:14%;min-width:220px;background:linear-gradient(180deg,var(--panel),#05121b);padding:14px;box-sizing:border-box;border-left:1px solid rgba(255,255,255,0.03)}
  canvas{display:block;background:linear-gradient(#0a1622,#022);}
  h1{font-size:18px;margin:0 0 12px 0;color:var(--accent)}
  .tool{display:flex;flex-direction:column;gap:8px}
  button,select{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);padding:8px;border-radius:8px;cursor:pointer}
  button.active{border-color:var(--accent);box-shadow:0 6px 18px rgba(0,209,255,0.06);color:#eaffff}
  .row{display:flex;gap:8px;margin-top:8px}
  .small{font-size:12px;color:#9fbccf}
  #legend{margin-top:12px;font-size:13px}
  .counter{margin:8px 0;padding:10px;border-radius:8px;background:rgba(0,0,0,0.12);font-weight:700}
  input[type=range]{width:100%}
  footer{position:absolute;left:12px;bottom:12px;color:#7fb}
</style>
</head>
<body>
<div id="app">
  <div id="left">
    <canvas id="game"></canvas>
    <footer>MiniCity prototype — créé par hamza</footer>
  </div>
  <div id="ui">
    <h1>MiniCity</h1>
    <div class="tool">
      <div class="small">Outils</div>
      <div class="row">
        <button id="tool-road" class="active">Route</button>
        <button id="tool-house">Maison</button>
      </div>
      <div class="row">
        <button id="tool-tree">Arbre</button>
        <button id="tool-erase">Gomme</button>
      </div>

      <div class="small" style="margin-top:10px">Simulation</div>
      <div class="row">
        <button id="start">Démarrer</button>
        <button id="pause">Pause</button>
      </div>

      <div class="counter"><div>Véhicules: <span id="countCars">0</span></div><div>Habitants: <span id="countPop">0</span></div></div>

      <div class="small">Zoom</div>
      <input id="zoom" type="range" min="0.6" max="2.2" step="0.1" value="1">

      <div class="small" style="margin-top:8px">Spawn rate (cars)</div>
      <input id="spawnRate" type="range" min="0" max="2" step="0.1" value="0.8">

      <div class="small" style="margin-top:8px">Sauvegarde</div>
      <div class="row">
        <button id="save">Sauvegarder</button>
        <button id="load">Charger</button>
      </div>

      <div id="legend">
        <div class="small">Astuce:</div>
        <div class="small">- Trace des routes, place maisons à côté.</div>
        <div class="small">- Les voitures vont d'un bâtiment à un autre via les routes.</div>
      </div>
    </div>
  </div>
</div>

<script>
/* ===== MiniCity - Isometric tile simulation =====
   Features:
   - isometric tilemap rendered on canvas
   - tools: draw road / place house / tree / erase
   - cars spawn and pathfind on roads between houses
   - zoom and pan (drag)
   - save/load (localStorage)
   This is a single-file prototype ready to deploy on GitHub Pages.
*/

// -------- config --------
const TILE_W = 64, TILE_H = 32;      // isometric tile size
const MAP_W = 80, MAP_H = 80;        // grid size
const CANVAS_MARGIN = 100;

// tile types: 0 empty, 1 road, 2 house, 3 tree
let map = new Uint8Array(MAP_W * MAP_H);
let buildings = []; // houses list {i,j,id}
let cars = [];      // car objects
let carId = 1;

// UI nodes
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const toolRoad = document.getElementById('tool-road');
const toolHouse = document.getElementById('tool-house');
const toolTree = document.getElementById('tool-tree');
const toolErase = document.getElementById('tool-erase');
const startBtn = document.getElementById('start');
const pauseBtn = document.getElementById('pause');
const zoomSlider = document.getElementById('zoom');
const spawnRateInput = document.getElementById('spawnRate');
const saveBtn = document.getElementById('save');
const loadBtn = document.getElementById('load');
const countCars = document.getElementById('countCars');
const countPop = document.getElementById('countPop');

let currentTool = 'road';
let running = false;
let zoom = parseFloat(zoomSlider.value);
let spawnRate = parseFloat(spawnRateInput.value);

// camera / pan
let camX = 0, camY = 0;
let isPanning = false, lastPan = null;

// initialize canvas size
function resize(){
  canvas.width = Math.max(800, window.innerWidth * 0.86);
  canvas.height = Math.max(600, window.innerHeight - 20);
  // center map
  camX = canvas.width/2;
  camY = 120;
}
window.addEventListener('resize', resize);
resize();

// helper: grid index
function idx(i,j){ return i + j*MAP_W; }

// simple get/set
function getTile(i,j){ if(i<0||j<0||i>=MAP_W||j>=MAP_H) return 0; return map[idx(i,j)]; }
function setTile(i,j,v){
  if(i<0||j<0||i>=MAP_W||j>=MAP_H) return;
  map[idx(i,j)] = v;
}

// iso projection (grid -> screen)
function isoToScreen(i,j){
  const x = (i - j) * (TILE_W/2);
  const y = (i + j) * (TILE_H/2);
  return {x: x*zoom + camX, y: y*zoom + camY};
}
function screenToIso(sx,sy){
  const x = (sx - camX)/zoom;
  const y = (sy - camY)/zoom;
  const i = Math.round( (y / (TILE_H/2) + x / (TILE_W/2)) /2 );
  const j = Math.round( (y / (TILE_H/2) - x / (TILE_W/2)) /2 );
  return {i,j};
}

// draw one tile base (flat ground)
function drawGround(i,j){
  const p = isoToScreen(i,j);
  const x = p.x, y = p.y;
  // diamond
  ctx.beginPath();
  ctx.moveTo(x, y - TILE_H/2*zoom);
  ctx.lineTo(x + TILE_W/2*zoom, y);
  ctx.lineTo(x, y + TILE_H/2*zoom);
  ctx.lineTo(x - TILE_W/2*zoom, y);
  ctx.closePath();
  ctx.fillStyle = "#0b2b22";
  ctx.fill();
  ctx.strokeStyle = "rgba(0,0,0,0.06)";
  ctx.stroke();
}

// draw road tile
function drawRoad(i,j){
  const p = isoToScreen(i,j);
  const x = p.x, y = p.y;
  ctx.beginPath();
  ctx.moveTo(x - TILE_W/4*zoom, y - TILE_H/8*zoom);
  ctx.lineTo(x + TILE_W/4*zoom, y - TILE_H/8*zoom);
  ctx.lineTo(x + TILE_W/4*zoom, y + TILE_H/8*zoom);
  ctx.lineTo(x - TILE_W/4*zoom, y + TILE_H/8*zoom);
  ctx.closePath();
  ctx.fillStyle = "#3a3a3a";
  ctx.fill();
  ctx.strokeStyle = "rgba(0,0,0,0.2)";
  ctx.stroke();
}

// draw house
function drawHouse(i,j){
  const p = isoToScreen(i,j);
  const x = p.x, y = p.y;
  // base
  ctx.fillStyle = "#caa48a";
  ctx.fillRect(x-18*zoom, y-28*zoom, 36*zoom, 22*zoom);
  // roof
  ctx.beginPath();
  ctx.moveTo(x-22*zoom, y-28*zoom);
  ctx.lineTo(x, y-48*zoom);
  ctx.lineTo(x+22*zoom, y-28*zoom);
  ctx.closePath();
  ctx.fillStyle = "#8b3b2b";
  ctx.fill();
  ctx.strokeStyle = "rgba(0,0,0,0.18)"; ctx.stroke();
}

// draw tree
function drawTree(i,j){
  const p = isoToScreen(i,j);
  const x = p.x, y = p.y;
  ctx.beginPath();
  ctx.arc(x, y-8*zoom, 10*zoom, 0, Math.PI*2);
  ctx.fillStyle = "#167639";
  ctx.fill();
  ctx.fillStyle = "#0b2c18";
  ctx.fillRect(x-2*zoom, y-8*zoom, 4*zoom, 8*zoom);
}

// draw car sprite
function drawCar(car){
  const p = isoToScreen(car.i + car.tdx, car.j + car.tdy);
  const x = p.x, y = p.y - 6*zoom;
  ctx.save();
  ctx.translate(x,y);
  ctx.rotate(car.angle);
  // car body
  ctx.fillStyle = car.color;
  ctx.fillRect(-6*zoom, -3*zoom, 12*zoom, 6*zoom);
  // windshield
  ctx.fillStyle = "#e8ffff"; ctx.fillRect(-3*zoom, -2*zoom, 6*zoom, 3*zoom);
  ctx.restore();
}

// render loop
function render(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // draw ground tiles (only visible region)
  const margin = 12;
  for(let j=0;j<MAP_H;j++){
    for(let i=0;i<MAP_W;i++){
      const p = isoToScreen(i,j);
      if(p.x < -1000 || p.x > canvas.width+1000 || p.y < -1000 || p.y > canvas.height+1000) continue;
      drawGround(i,j);
    }
  }
  // draw roads and buildings in correct order (simple painter)
  for(let j=0;j<MAP_H;j++){
    for(let i=0;i<MAP_W;i++){
      const t = getTile(i,j);
      if(t===1) drawRoad(i,j);
      else if(t===2) drawHouse(i,j);
      else if(t===3) drawTree(i,j);
    }
  }
  // draw cars
  for(const car of cars) drawCar(car);

  // counters
  countCars.textContent = cars.length;
  countPop.textContent = buildings.length * 3; // rough pop per house
  requestAnimationFrame(render);
}
requestAnimationFrame(render);

// ------- tools behavior -------
function setActiveTool(name){
  currentTool = name;
  [toolRoad,toolHouse,toolTree,toolErase].forEach(b=>{
    b.classList.toggle('active', b.id === 'tool-'+name);
  });
}
toolRoad.onclick = ()=> setActiveTool('road');
toolHouse.onclick = ()=> setActiveTool('house');
toolTree.onclick = ()=> setActiveTool('tree');
toolErase.onclick = ()=> setActiveTool('erase');

zoomSlider.oninput = ()=> { zoom = parseFloat(zoomSlider.value); };
spawnRateInput.oninput = ()=> { spawnRate = parseFloat(spawnRateInput.value); };

// painting on click / drag
let mouseDown = false;
canvas.addEventListener('mousedown', (e)=>{
  const rc = canvas.getBoundingClientRect();
  const sx = e.clientX - rc.left;
  const sy = e.clientY - rc.top;
  if(e.button === 1 || e.button === 2){ // middle or right to pan
    isPanning = true; lastPan = {x:e.clientX, y:e.clientY}; return;
  }
  mouseDown = true;
  applyToolAt(sx,sy);
});
canvas.addEventListener('mousemove', (e)=>{
  const rc = canvas.getBoundingClientRect();
  const sx = e.clientX - rc.left;
  const sy = e.clientY - rc.top;
  if(isPanning && lastPan){
    camX += e.clientX - lastPan.x;
    camY += e.clientY - lastPan.y;
    lastPan = {x:e.clientX, y:e.clientY};
  }
  if(mouseDown) applyToolAt(sx,sy);
});
window.addEventListener('mouseup', ()=>{ mouseDown = false; isPanning = false; lastPan = null; });

function applyToolAt(sx,sy){
  const {i,j} = screenToIso(sx,sy);
  if(i<0||j<0||i>=MAP_W||j>=MAP_H) return;
  if(currentTool === 'road'){ setTile(i,j,1); }
  else if(currentTool === 'house'){
    // only place house if adjacent to road
    if(adjacentToRoad(i,j)){
      setTile(i,j,2);
      buildings.push({i,j,id:buildings.length+1});
    }
  } else if(currentTool === 'tree'){ setTile(i,j,3); }
  else if(currentTool === 'erase'){ 
    if(getTile(i,j)===2){
      // remove building from array
      buildings = buildings.filter(b=>!(b.i===i && b.j===j));
    }
    setTile(i,j,0);
  }
}

// check adjacent tile is road
function adjacentToRoad(i,j){
  const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
  for(const d of dirs) if(getTile(i+d[0], j+d[1])===1) return true;
  return false;
}

// ------- simple pathfinding (grid A* on road tiles) -------
function findPath(si,sj,ti,tj){
  // restrict to positions where tiles are road
  // both start and target are supposed to be road-adjacent; here we find nearest road cell
  const start = findNearestRoadCell(si,sj);
  const goal = findNearestRoadCell(ti,tj);
  if(!start || !goal) return null;
  const key = (a,b)=> a + "," + b;
  const open = new Map(); // key -> node
  const closed = new Set();
  function h(a,b){ return Math.abs(a-goal.i) + Math.abs(b-goal.j); }
  const startKey = key(start.i,start.j);
  open.set(startKey, {i:start.i,j:start.j,g:0,f:h(start.i,start.j),parent:null});
  const maxIter = 5000;
  let iter = 0;
  while(open.size && iter++ < maxIter){
    // pick smallest f
    let curKey, curNode;
    for(const [k,n] of open){ if(!curNode || n.f < curNode.f){ curNode=n; curKey=k; } }
    open.delete(curKey);
    closed.add(curKey);
    if(curNode.i===goal.i && curNode.j===goal.j){
      // reconstruct
      const path = [];
      let n = curNode;
      while(n){ path.push({i:n.i,j:n.j}); n = n.parent; }
      path.reverse();
      return path;
    }
    const neighbors = [[1,0],[-1,0],[0,1],[0,-1]];
    for(const nb of neighbors){
      const ni = curNode.i + nb[0], nj = curNode.j + nb[1];
      const nk = key(ni,nj);
      if(closed.has(nk)) continue;
      if(getTile(ni,nj) !== 1) continue; // only road tiles
      const g = curNode.g + 1;
      const hcost = h(ni,nj);
      const f = g + hcost;
      const existing = open.get(nk);
      if(!existing || g < existing.g){
        open.set(nk, {i:ni,j:nj,g, f, parent:curNode});
      }
    }
  }
  return null;
}
function findNearestRoadCell(i,j){
  if(getTile(i,j)===1) return {i,j};
  // BFS spiral
  const maxR = 10;
  for(let r=1;r<=maxR;r++){
    for(let dx=-r;dx<=r;dx++){
      for(let dy=-r;dy<=r;dy++){
        if(Math.abs(dx)!==r && Math.abs(dy)!==r) continue;
        const ni = i+dx, nj = j+dy;
        if(ni<0||nj<0||ni>=MAP_W||nj>=MAP_H) continue;
        if(getTile(ni,nj)===1) return {i:ni,j:nj};
      }
    }
  }
  return null;
}

// ------- car simulation -------
function spawnCar(){
  if(buildings.length < 2) return;
  // pick two houses randomly
  const a = buildings[Math.floor(Math.random()*buildings.length)];
  const b = buildings[Math.floor(Math.random()*buildings.length)];
  if(a===b) return;
  const path = findPath(a.i,a.j,b.i,b.j);
  if(!path || path.length<2) return;
  const car = {
    id: carId++,
    path,
    posIndex:0,
    progress:0,
    speed: 0.004 + Math.random()*0.006,
    color: pickColor(),
    i: path[0].i, j: path[0].j, tdx:0, tdy:0, angle:0
  };
  cars.push(car);
}
function pickColor(){
  const col = ["#ffcc00","#ff6666","#66ff66","#66ccff","#ff66cc","#ffaa66"];
  return col[Math.floor(Math.random()*col.length)];
}
function updateCars(dt){
  for(let k=cars.length-1;k>=0;k--){
    const c = cars[k];
    c.progress += c.speed * dt * 0.06;
    const seg = c.path;
    if(c.posIndex >= seg.length-1){ // reached
      cars.splice(k,1); continue;
    }
    // interpolate between seg[posIndex] and seg[posIndex+1]
    const a = seg[c.posIndex], b = seg[c.posIndex+1];
    const t = Math.min(1, c.progress);
    c.i = a.i; c.j = a.j;
    // compute normalized dx/dy for sub-tile offset to render between tiles
    c.tdx = (b.i - a.i) * t;
    c.tdy = (b.j - a.j) * t;
    // angle
    const sx = (b.i - a.i), sy = (b.j - a.j);
    c.angle = Math.atan2((sx - sy), (sx + sy)) * 0.8; // cosmetic
    if(c.progress >= 1){
      c.posIndex++;
      c.progress = 0;
      if(c.posIndex >= seg.length-1){
        // reached dest, remove after small delay
        cars.splice(k,1);
      }
    }
  }
}

// main sim tick
let lastTick = performance.now();
function tick(){
  const now = performance.now();
  const dt = Math.min(40, now - lastTick);
  lastTick = now;
  if(running){
    // spawn cars randomly based on spawnRate
    if(Math.random() < spawnRate * dt * 0.001) spawnCar();
    updateCars(dt);
  }
  requestAnimationFrame(tick);
}
tick();

// UI events
startBtn.onclick = ()=> running = true;
pauseBtn.onclick = ()=> running = false;
zoomSlider.oninput = ()=> { zoom = parseFloat(zoomSlider.value); };
spawnRateInput.oninput = ()=> { spawnRate = parseFloat(spawnRateInput.value); };

saveBtn.onclick = ()=>{
  const data = {
    map: Array.from(map),
    buildings,
    camX, camY, zoom
  };
  localStorage.setItem('minicity_save', JSON.stringify(data));
  alert('Sauvegardé localement');
};
loadBtn.onclick = ()=>{
  const raw = localStorage.getItem('minicity_save');
  if(!raw) return alert('Aucune sauvegarde trouvée');
  const d = JSON.parse(raw);
  map = Uint8Array.from(d.map);
  buildings = d.buildings || [];
  camX = d.camX || camX; camY = d.camY || camY; zoom = d.zoom || zoom;
  zoomSlider.value = zoom;
  alert('Chargé');
};

// initial demo: small road + houses
(function seedDemo(){
  for(let y=38;y<42;y++) for(let x=20;x<60;x++) if(y===39||y===40) setTile(x,y,1);
  // small cross road
  for(let y=32;y<48;y++) setTile(40,y,1);
  // houses
  setTile(38,38,2); buildings.push({i:38,j:38,id:1});
  setTile(42,38,2); buildings.push({i:42,j:38,id:2});
  setTile(30,34,2); buildings.push({i:30,j:34,id:3});
})();

// allow arrow keys to pan
window.addEventListener('keydown',(e)=>{
  const step = 40;
  if(e.key==='ArrowLeft') camX += step;
  if(e.key==='ArrowRight') camX -= step;
  if(e.key==='ArrowUp') camY += step;
  if(e.key==='ArrowDown') camY -= step;
});

// show simple help on first load
if(!localStorage.getItem('minicity_seen_help')){
  alert('MiniCity : utilise la souris pour dessiner. Clic droit/milieu pour déplacer la carte. Place routes puis maisons. Start pour lancer la circulation.');
  localStorage.setItem('minicity_seen_help','1');
}
</script>
</body>
</html>
